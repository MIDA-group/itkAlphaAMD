
#include <stdio.h>
#include <string.h>
#include <string>

//#include "itkLBFGSOptimizer.h"
#include "itkImageFileWriter.h"
#include "itkResampleImageFilter.h"
#include "itkCastImageFilter.h"
#include "itkSquaredDifferenceImageFilter.h"

#include "itkImageRegistrationMethod.h"
#include "itkMeanSquaresImageToImageMetric.h"
#include "itkTimeProbesCollectorBase.h"
#include "itkSpatialObjectToImageFilter.h"
#include "itkEllipseSpatialObject.h"

#include "common/itkImageProcessingTools.h"
#include "itkTextOutput.h"

#include "itkTimeProbesCollectorBase.h"
#include "itkMemoryProbesCollectorBase.h"

#include "metric/itkAlphaSMDMetricDeform.h"

// For BSpline transform resampling
#include "itkBSplineResampleImageFunction.h"
#include "itkIdentityTransform.h"
#include "itkBSplineDecompositionImageFilter.h"

#include "itkCheckerBoardImageFilter.h"
#include "itkTransformToDisplacementFieldFilter.h"
#include "itkFlatStructuringElement.h"
#include "itkBinaryDilateImageFilter.h"

#include "itkGradientMagnitudeImageFilter.h"
#include "itkDisplacementFieldJacobianDeterminantFilter.h"

#include <fstream>
#include <sstream>
#include <string>
#include "itkRawImageIO.h"
#include "itkImageFileReader.h"

#include "itkExtractImageFilter.h"

struct BSplineRegParam
{
    double learningRate1;
    double learningRate2;
    double lambdaFactor;
    int iterations;
    double samplingFraction;
    std::vector<int> controlPoints;
};

template <unsigned int ImageDimension = 3U>
class BSplines {
public:

typedef double PixelType;
typedef double CoordinateRepType;

typedef typename itk::Image<PixelType, ImageDimension> ImageType;
typedef typename ImageType::Pointer ImagePointer;

typedef typename itk::Vector<PixelType, ImageDimension> VectorPixelType;
typedef typename itk::Image<VectorPixelType, ImageDimension> DisplacementFieldImageType;
typedef typename DisplacementFieldImageType::Pointer DisplacementFieldImagePointer;

typedef typename itk::IPT<double, ImageDimension> IPT;


template <typename TransformType>
DisplacementFieldImagePointer TransformToDisplacementField(typename TransformType::Pointer transform, ImagePointer reference_image) {
  typedef typename itk::TransformToDisplacementFieldFilter<DisplacementFieldImageType, CoordinateRepType> DisplacementFieldGeneratorType;

  typename DisplacementFieldGeneratorType::Pointer dfield_gen = DisplacementFieldGeneratorType::New();

  dfield_gen->UseReferenceImageOn();
  dfield_gen->SetReferenceImage(reference_image);
  dfield_gen->SetTransform(transform);
  try {
    dfield_gen->Update();
  } catch (itk::ExceptionObject & err) {
    std::cerr << "Error while generating deformation field: " << err << std::endl;
  }

  return dfield_gen->GetOutput();
}

ImagePointer JacobianDeterminantFilter(DisplacementFieldImagePointer dfield) {
  typedef typename itk::DisplacementFieldJacobianDeterminantFilter<DisplacementFieldImageType, PixelType, ImageType> FilterType;
  typename FilterType::Pointer filter = FilterType::New();

  filter->SetInput(dfield);
  filter->SetUseImageSpacingOn();

  filter->Update();

  return filter->GetOutput();
}

DisplacementFieldImagePointer LoadDisplacementField(std::string path) {
  typedef typename itk::ImageFileReader<DisplacementFieldImageType> FieldReaderType;
  typename FieldReaderType::Pointer reader = FieldReaderType::New();

  reader->SetFileName(path.c_str());

  reader->Update();

  return reader->GetOutput();
}

void SaveDisplacementField(DisplacementFieldImagePointer image, std::string path) {
  typedef typename itk::ImageFileWriter<DisplacementFieldImageType> FieldWriterType;
  typename FieldWriterType::Pointer writer = FieldWriterType::New();

  writer->SetInput(image);

  writer->SetFileName(path.c_str());

  try {
    writer->Update();
  } catch (itk::ExceptionObject & err) {
    std::cerr << "Error while writing displacement field: " << err << std::endl;
  }
}

void SaveJacobianDeterminantImage(ImagePointer image, std::string path) {
  typedef typename itk::ImageFileWriter<ImageType> FieldWriterType;
  typename FieldWriterType::Pointer writer = FieldWriterType::New();

  writer->SetInput(image);

  writer->SetFileName(path.c_str());

  try {
    writer->Update();
  } catch (itk::ExceptionObject & err) {
    std::cerr << "Error while writing jacobian determinant: " << err << std::endl;
  }
}

static void CreateEllipseImage(typename ImageType::Pointer image);
static void CreateCircleImage(typename ImageType::Pointer image);

constexpr static unsigned int splineOrder = 3;

typedef typename itk::BSplineTransform<double, ImageDimension, splineOrder> TransformType;
typedef typename TransformType::Pointer TransformPointer;

typedef itk::AlphaSMDObjectToObjectMetricDeformv4<ImageType, ImageDimension, double, splineOrder> MetricType;
typedef typename MetricType::Pointer MetricPointer;


ImagePointer GradientMagnitudeImage(ImagePointer image, double sigma) {
    typedef typename itk::IPT<double, ImageDimension> IPT;
    if(sigma > 0.0) {
        image = IPT::SmoothImage(image, sigma);
    }
    typedef typename itk::GradientMagnitudeImageFilter<ImageType, ImageType> GradientMagnitudeFilterType;
    typename GradientMagnitudeFilterType::Pointer gmFilter = GradientMagnitudeFilterType::New();

    gmFilter->SetInput(image);
    gmFilter->SetUseImageSpacingOn();
    gmFilter->Update();

    return gmFilter->GetOutput();
}

typename IPT::BinaryImagePointer DilateMask(typename IPT::BinaryImagePointer mask, int radiusValue) {
    using StructuringElementType = itk::FlatStructuringElement< ImageDimension >;
    typename StructuringElementType::RadiusType radius;
    radius.Fill( radiusValue );
    StructuringElementType structuringElement = typename StructuringElementType::Ball( radius );

    using BinaryDilateImageFilterType = itk::BinaryDilateImageFilter<typename IPT::BinaryImageType, typename IPT::BinaryImageType, StructuringElementType>;
    typename BinaryDilateImageFilterType::Pointer dilateFilter = BinaryDilateImageFilterType::New();
    dilateFilter->SetInput(mask);
    dilateFilter->SetKernel(structuringElement);

    dilateFilter->Update();
    return dilateFilter->GetOutput();
}

ImagePointer Chessboard(ImagePointer image1, ImagePointer image2, int cells)
{
    itk::FixedArray<unsigned int, ImageDimension> pattern;
    pattern.Fill(cells);

    typedef typename itk::IPT<double, ImageDimension> IPT;
    typedef typename itk::CheckerBoardImageFilter<ImageType> CheckerBoardFilterType;
    typename CheckerBoardFilterType::Pointer checkerBoardFilter = CheckerBoardFilterType::New();
    checkerBoardFilter->SetInput1(image1);
    checkerBoardFilter->SetInput2(image2);
    checkerBoardFilter->SetCheckerPattern(pattern);
    checkerBoardFilter->Update();
    return checkerBoardFilter->GetOutput();
}

ImagePointer BlackAndWhiteChessboard(ImagePointer refImage, int cells)
{
    typedef itk::IPT<double, ImageDimension> IPT;
    return Chessboard(IPT::ZeroImage(refImage->GetLargestPossibleRegion().GetSize()), IPT::ConstantImage(1.0, refImage->GetLargestPossibleRegion().GetSize()), cells);
}


std::vector<std::string> read_strings(std::string path)
{
    std::vector<std::string> result;
    std::ifstream infile(path.c_str());

    std::string line;
    while (std::getline(infile, line))
    {
        result.push_back(line);
    }

    return result;
}

template <typename TPixelType, unsigned int TImageDimension>
ImagePointer readRawIntegerFile(std::string path)
{
    std::vector<std::string> hdr = read_strings(path);

    assert(hdr.size() >= 1 + TImageDimension * 2);

    std::string data_path = hdr[0];
    int nPixels[TImageDimension];
    double szVoxels[TImageDimension];

    for (int i = 0; i < TImageDimension; ++i)
    {
        nPixels[i] = atoi(hdr[1 + i].c_str());
        szVoxels[i] = atof(hdr[1 + TImageDimension + i].c_str());
    }

    typedef itk::RawImageIO<TPixelType, TImageDimension> IOType;
    typedef typename IOType::Pointer IOPointer;

    IOPointer io = IOType::New();

    for (int i = 0; i < TImageDimension; ++i)
    {
        io->SetDimensions(i, nPixels[i]);
        io->SetSpacing(i, szVoxels[i]);
    }

    io->SetHeaderSize(io->GetImageSizeInPixels() * 0);
    io->SetByteOrderToLittleEndian();

    typedef itk::Image<TPixelType, TImageDimension> IntermediateImageType;

    typedef itk::ImageFileReader<IntermediateImageType> ReaderType;

    typedef itk::IPT<double, ImageDimension> IPT;

    typename ReaderType::Pointer reader = ReaderType::New();

    reader->SetFileName(data_path.c_str());
    reader->SetImageIO(io);

    return itk::ConvertImageFromIntegerFormat<TPixelType>(reader->GetOutput());
}


void saveSlice(ImagePointer image, int d, int ind, std::string path)
{
    typedef itk::Image<double, ImageDimension - 1> SliceImageType;

    typename ImageType::RegionType slice = image->GetLargestPossibleRegion();
    slice.SetIndex(d, ind);
    slice.SetSize(d, 0);
    typedef itk::IPT<double, ImageDimension - 1> IPT;

    using ExtractFilterType = itk::ExtractImageFilter<ImageType, SliceImageType>;
    typename ExtractFilterType::Pointer extract = ExtractFilterType::New();
    extract->SetDirectionCollapseToIdentity();
    extract->InPlaceOn();
    extract->SetInput(image);
    extract->SetExtractionRegion(slice);

    typename SliceImageType::Pointer sliceImage = extract->GetOutput();
    IPT::SaveImage(path.c_str(), sliceImage, false);
}

TransformPointer CreateBSplineTransform(ImagePointer image, unsigned int numberOfGridNodes)
{
    typename TransformType::PhysicalDimensionsType fixedPhysicalDimensions;
    typename TransformType::MeshSizeType meshSize;

    TransformPointer transform = TransformType::New();

    for (unsigned int i = 0; i < ImageDimension; i++)
    {
        fixedPhysicalDimensions[i] = image->GetSpacing()[i] *
                                     static_cast<double>(
                                         image->GetLargestPossibleRegion().GetSize()[i] - 1);
    }
    meshSize.Fill(numberOfGridNodes - splineOrder);
    transform->SetTransformDomainOrigin(image->GetOrigin());
    transform->SetTransformDomainPhysicalDimensions(fixedPhysicalDimensions);
    transform->SetTransformDomainMeshSize(meshSize);
    transform->SetTransformDomainDirection(image->GetDirection());

    return transform;
}

void UpsampleBSplineTransform(ImagePointer image, TransformPointer newTransform, TransformPointer oldTransform, unsigned int numberOfGridNodes)
{
    typedef typename TransformType::ParametersType ParametersType;
    ParametersType parameters(newTransform->GetNumberOfParameters());
    parameters.Fill(0.0);

    unsigned int counter = 0;
    for (unsigned int k = 0; k < ImageDimension; k++)
    {
        using ParametersImageType = typename TransformType::ImageType;
        using ResamplerType = itk::ResampleImageFilter<ParametersImageType, ParametersImageType>;
        typename ResamplerType::Pointer upsampler = ResamplerType::New();
        using FunctionType = itk::BSplineResampleImageFunction<ParametersImageType, double>;
        typename FunctionType::Pointer function = FunctionType::New();
        using IdentityTransformType = itk::IdentityTransform<double, ImageDimension>;
        typename IdentityTransformType::Pointer identity = IdentityTransformType::New();
        upsampler->SetInput(oldTransform->GetCoefficientImages()[k]);
        upsampler->SetInterpolator(function);
        upsampler->SetTransform(identity);
        upsampler->SetSize(newTransform->GetCoefficientImages()[k]->GetLargestPossibleRegion().GetSize());
        upsampler->SetOutputSpacing(
            newTransform->GetCoefficientImages()[k]->GetSpacing());
        upsampler->SetOutputOrigin(
            newTransform->GetCoefficientImages()[k]->GetOrigin());
        upsampler->SetOutputDirection(image->GetDirection());
        using DecompositionType =
            itk::BSplineDecompositionImageFilter<ParametersImageType, ParametersImageType>;
        typename DecompositionType::Pointer decomposition = DecompositionType::New();
        decomposition->SetSplineOrder(splineOrder);
        decomposition->SetInput(upsampler->GetOutput());
        decomposition->Update();
        typename ParametersImageType::Pointer newCoefficients = decomposition->GetOutput();
        // copy the coefficients into the parameter array
        using Iterator = itk::ImageRegionIterator<ParametersImageType>;
        Iterator it(newCoefficients,
                    newTransform->GetCoefficientImages()[k]->GetLargestPossibleRegion());
        while (!it.IsAtEnd())
        {
            parameters[counter++] = it.Get();
            ++it;
        }
    }
    newTransform->SetParameters(parameters);
}

typename ImageType::Pointer ApplyTransform(ImagePointer refImage, ImagePointer floImage, TransformPointer transform)
{
    typedef itk::ResampleImageFilter<
        ImageType,
        ImageType>
        ResampleFilterType;

    typedef itk::IPT<double, ImageDimension> IPT;

    typename ResampleFilterType::Pointer resample = ResampleFilterType::New();

    resample->SetTransform(transform);
    resample->SetInput(floImage);

    resample->SetSize(refImage->GetLargestPossibleRegion().GetSize());
    resample->SetOutputOrigin(refImage->GetOrigin());
    resample->SetOutputSpacing(refImage->GetSpacing());
    resample->SetOutputDirection(refImage->GetDirection());
    resample->SetDefaultPixelValue(0.5);

    resample->UpdateLargestPossibleRegion();

    return resample->GetOutput();
}

double normalizeDerivative(unsigned int gridPoints, unsigned int dim)
{
    // / 5.0
    double frac = pow(gridPoints, (double)dim);
    return frac;
}

double maxDerivative(itk::Array<double> &array)
{
    double sum = 0.0;
    unsigned int count = array.GetSize();
    for (unsigned int i = 0; i < count; ++i)
    {
        double value = fabs(array[i]);
        if (value > sum)
            sum = value;
    }
    return sum;
}

double norm(itk::Array<double> &array, double p, double eps = 1e-7)
{
    double sum = 0.0;
    unsigned int count = array.GetSize();
    for (unsigned int i = 0; i < count; ++i)
    {
        double value = pow(fabs(array[i]), p);
        sum += value;
    }
    sum = pow(sum, 1.0 / p);
    if (sum < eps)
        sum = eps;
    return sum;
}

void register_func(typename ImageType::Pointer fixedImage, typename ImageType::Pointer movingImage, TransformPointer& transformForward, TransformPointer& transformInverse, BSplineRegParam param, ImagePointer fixedMask, ImagePointer movingMask, bool verbose=false)
{
    typedef itk::IPT<double, ImageDimension> IPT;
    MetricPointer metric = MetricType::New();

    metric->SetRandomSeed(1337);

    metric->SetFixedImage(fixedImage);
    metric->SetMovingImage(movingImage);

    metric->SetAlphaLevels(7);

    metric->SetForwardTransformPointer(transformForward);
    metric->SetInverseTransformPointer(transformInverse);

    metric->SetFixedSamplingPercentage(param.samplingFraction);
    metric->SetMovingSamplingPercentage(param.samplingFraction);

    if(fixedMask) {
        typename IPT::BinaryImagePointer maskBin = IPT::ThresholdImage(fixedMask, 0.01);

        metric->SetFixedMask(maskBin);
    }
    if(movingMask) {
        typename IPT::BinaryImagePointer maskBin = IPT::ThresholdImage(movingMask, 0.01);

        metric->SetMovingMask(maskBin);
    }

    itk::TimeProbesCollectorBase chronometer;
    itk::MemoryProbesCollectorBase memorymeter;

    chronometer.Start("Pre-processing");
    memorymeter.Start("Pre-processing");

    metric->Update();

    chronometer.Stop("Pre-processing");
    memorymeter.Stop("Pre-processing");

    //chronometer.Report( std::cout );
    //memorymeter.Report( std::cout );

    typedef typename MetricType::MeasureType MeasureType;
    typedef typename MetricType::DerivativeType DerivativeType;

    MeasureType value;
    DerivativeType derivative(metric->GetNumberOfParameters());
    DerivativeType derAcc(metric->GetNumberOfParameters());

    derAcc.fill(0.0);

    typedef itk::IPT<double, ImageDimension> IPT;

    const double gt_percentage = 0.01;

    metric->SetSymmetryLambda(param.lambdaFactor);
    metric->SetFixedSamplingPercentage(gt_percentage);
    metric->SetMovingSamplingPercentage(gt_percentage);
    metric->GetValueAndDerivative(value, derivative);
    
    metric->SetFixedSamplingPercentage(param.samplingFraction);
    metric->SetMovingSamplingPercentage(param.samplingFraction);
    metric->SetSymmetryLambda(param.lambdaFactor);
    double p = 2.0;
    double maxGrad = 0.0;
    double momentum = 0.0;
    double maxMomentum = 0.0;
    double meanValue = value;

    chronometer.Start("Registration");
    memorymeter.Start("Registration");

    for (int q = 0; q < param.controlPoints.size(); ++q) {
        if(q > 0) {
            TransformPointer tforNew = CreateBSplineTransform(fixedImage, param.controlPoints[q]);
            TransformPointer tinvNew = CreateBSplineTransform(movingImage, param.controlPoints[q]);
            int curNumberOfGridNodes = param.controlPoints[q];
            UpsampleBSplineTransform(fixedImage, tforNew, transformForward, curNumberOfGridNodes);
            UpsampleBSplineTransform(movingImage, tinvNew, transformInverse, curNumberOfGridNodes);
            transformForward = tforNew;
            transformInverse = tinvNew;

            metric->SetForwardTransformPointer(transformForward);
            metric->SetInverseTransformPointer(transformInverse);
            metric->UpdateAfterTransformChange();
            derivative = DerivativeType(metric->GetNumberOfParameters());
            derAcc = DerivativeType(metric->GetNumberOfParameters());
            derAcc.fill(0.0);
        }
    std::cout << "Initial loss: " << meanValue << std::endl;

    std::vector<double> valueHistory;

    for (int i = 0; i < param.iterations; ++i)
    {
        clock_t time1 = clock();

        double alpha = (double)i / param.iterations;
        double learningRate = param.learningRate1 * (1.0 - alpha) + param.learningRate2 * alpha;
        //metric->SetDoRandomize(false);
        metric->GetValueAndDerivative(value, derivative);
        itk::Vector<double, 2U> valuePair = metric->GetMetricValues();

	/*        for (unsigned int j = 0; j < metric->GetNumberOfParameters(); ++j)
        {
            derivative[j] = derAcc[j] * (momentum) + derivative[j] * (1.0 - momentum);
            derAcc[j] = derivative[j];
	    }*/
        //norm(derivative, p)
        //maxGrad = (1.0 - maxMomentum) * maxDerivative(derivative) + maxMomentum * maxGrad;
	
        double curLR = learningRate;// / maxDerivative(derivative); //normalizeDerivative(param.controlPoints, ImageDimension);

        metric->UpdateTransformParameters(derivative, curLR);

        clock_t time2 = clock();

        valueHistory.push_back(value);
        meanValue = valueHistory[0];
        for(size_t k = 1; k < valueHistory.size(); ++k) {
            meanValue += valueHistory[k];
        }
        meanValue = meanValue / valueHistory.size();
	
        double timeElapsed = (time2-time1)/((double)CLOCKS_PER_SEC);

        //if (i % 5 == 0 || (i + 1) == param.iterations)
        if (verbose && (i % 10 == 0 || (i+1) == param.iterations))
        {
            std::cout << "Iteration " << (i + 1) << "... Value: " << valuePair << "(" << meanValue << ")" << ", Derivative: " << maxGrad << ", lr: " << curLR << ", Time: " << timeElapsed << std::endl;
            //std::cout << metric->GetParameters() << std::endl;
            //std::cout << "Derivative: " << derivative << std::endl;
        }
    }

    typename MetricType::ParametersType parameters(metric->GetParameters());
    double absVal = 0.0;
    double val = 0.0;
    for(unsigned int j = 0; j < metric->GetNumberOfParameters(); ++j) {
        if(fabs(parameters[j]) > absVal) {
            absVal = fabs(parameters[j]);
            val = parameters[j];
        }
    }
    std::cout << "Largest parameters: " << absVal << std::endl;

    }

    chronometer.Stop("Registration");
    memorymeter.Stop("Registration");

    chronometer.Report(std::cout);
    memorymeter.Report(std::cout);
/*
    metric->SetSymmetryLambda(1.0);
    */
    metric->SetFixedSamplingPercentage(gt_percentage);
    metric->SetMovingSamplingPercentage(gt_percentage);
    metric->GetValueAndDerivative(value, derivative);

    std::cout << "Final Loss: " << value << std::endl;
}

void print_difference_image_stats(ImagePointer image1, ImagePointer image2, const char* name) {
    typedef itk::IPT<double, ImageDimension> IPT;
    typename ImageType::Pointer diff = IPT::DifferenceImage(image1, image2);

    typename IPT::ImageStatisticsData movingStats = IPT::ImageStatistics(diff);

    std::cout << name << " mean: " << movingStats.mean << ", std: " << movingStats.sigma << std::endl;
}

};
